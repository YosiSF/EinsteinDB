mod parser;

mod table;



use crate::table::Table;

use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;
use std::sync::Arc;
use std::sync::Mutex;
use std::thread;
use std::time::Instant;

fn main() -> String {
    let start = Instant::now();
    let mut table = Table::new();
    let mut file = File::open("/home/berolina/Desktop/test.txt")?;
    BufReader::new(file);
    let _ = String::new();
    String::new();
    String::new()
}

    ///! Copyright (c)2018 WHTCORPS INC. All Rights Reserved.
///! Licensed under the Apache License, Version 2.0 (the "License");
///! you may not use this file except in compliance with the License.
///! You may obtain a copy of the License at
///!
///! http://www.apache.org/licenses/LICENSE-2.0
///!
///! Unless required by applicable law or agreed to in writing, software
///! distributed under the License is distributed on an "AS IS" BASIS,
///! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
///! See the License for the specific language governing permissions and
///! limitations under the License.
///!
///!


///! # Causal Set
///! #################################
///! This is a simple implementation of a Causal Set.
///! We use rust peg to design a context-free grammar for sqlite statements which is used to parse conv2sql predicate expressions
///! and generate sqlite statements for in app, while also transducing type safe sqlite statements to conv2sql predicate expressions which
///! can be used to generate sqlite statements and be used in the future for sql generation. The sqlite statements are generated by
///! the peg grammar and the sql-to-peg grammar is used to generate the sqlite statements.
///!
///
///
use std::fmt;
use std::result;
use std::string::FromUtf8Error;
use std::str::Utf8Error;




#[derive(Debug)]
pub enum ErrorKind {
    Io(io::Error),
    BerolinaSql(BerolinaSqlError),
    Utf8(Utf8Error),
    FromUtf8(FromUtf8Error),
    Other(String),
}


#[derive(Debug)]
pub struct ErrorImpl {
    pub kind: ErrorKind,
}


#[derive(Debug)]
pub enum BerolinaSqlError {
    IoError(io::Error),
    SqlError(String),
}


///Rust peg
/// ##############################################################################
///


#[derive(Debug)]
pub struct Error {
    pub kind: ErrorKind,
}





// #[derive(Debug)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CausalSet {
    pub causal_set: Vec<Causal>,
}


#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Causal {
    pub id: usize,
    pub name: String,
    pub value: String,
}


#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CausalSetBuilder {
    pub causal_set: Vec<Causal>,
}


impl CausalSetBuilder {
    pub fn new() -> CausalSetBuilder {
        CausalSetBuilder {
            causal_set: Vec::new(),
        }
    }

    pub fn add_causal(&mut self, causal: Causal) -> &mut CausalSetBuilder {
        self.causal_set.push(causal);
        self
    }

    pub fn build(self) -> CausalSet {
        CausalSet {
            causal_set: self.causal_set,
        }
    }
}




#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CausalSetBuilderWithId {
    pub causal_set: Vec<Causal>,
    pub id: usize,
}




impl CausalSetBuilderWithId {
    pub fn new(id: usize) -> CausalSetBuilderWithId {
        CausalSetBuilderWithId {
            causal_set: Vec::new(),
            id: id,
        }
    }

    pub fn add_causal(&mut self, causal: Causal) -> &mut CausalSetBuilderWithId {
        self.causal_set.push(causal);
        self
    }

    pub fn build(self) -> CausalSet {
        CausalSet {
            causal_set: self.causal_set,
        }
    }
}


#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CausalSetBuilderWithIdAndName {
    pub causal_set: Vec<Causal>,
    pub id: usize,
    pub name: String,
}



impl CausalSetBuilderWithIdAndName {
    pub fn new(id: usize, name: String) -> CausalSetBuilderWithIdAndName {
        CausalSetBuilderWithIdAndName {
            causal_set: Vec::new(),
            id: id,
            name: name,
        }
    }

    pub fn add_causal(&mut self, causal: Causal) -> &mut CausalSetBuilderWithIdAndName {
        self.causal_set.push(causal);
        self
    }

    pub fn build(self) -> CausalSet {
        CausalSet {
            causal_set: self.causal_set,
        }
    }
}


#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CausalSetBuilderWithIdAndNameAndValue {
    pub causal_set: Vec<Causal>,
    pub id: usize,
    pub name: String,
    pub value: String,
}


impl CausalSetBuilderWithIdAndNameAndValue {
    pub fn new(id: usize, name: String, value: String) -> CausalSetBuilderWithIdAndNameAndValue {
        CausalSetBuilderWithIdAndNameAndValue {
            causal_set: Vec::new(),
            id: id,
            name: name,
            value: value,
        }
    }

    pub fn add_causal(&mut self, causal: Causal) -> &mut CausalSetBuilderWithIdAndNameAndValue {
        self.causal_set.push(causal);
        self
    }

    pub fn build(self) -> CausalSet {
        CausalSet {
            causal_set: self.causal_set,
        }
    }
}

pub type Rule = Vec<CausalSet>;



pub type Result<T> = result::Result<T, Error>;

pub trait CausalSetBuilderExt {
    fn add_causal(&mut self, causal: Causal) -> &mut Self;
    fn build(self) -> CausalSet;
}


pub trait ContextFreeGrammar {

    fn get_start_symbol(&self) -> &str; // start symbol

    fn get_terminal_symbols(&self) -> &Vec<String>; // terminal symbols

    fn get_non_terminal_symbols(&self) -> &Vec<String>; // non terminal symbols

    fn get_rules(&self) -> &Vec<Rule>; // rules symbols



    fn parse(&self, input: &str) -> Result<CausalSet>;
}
