mod parser;

mod table;
mod decimal;
mod error;
mod binary;
mod comparison;
mod json_type;
mod json_modify;
mod overflow;








use std::fs::File;
use std::io::{self, BufRead, BufReader};




use std::time::Instant;


///! Copyright (c)2018 WHTCORPS INC. All Rights Reserved.
///! Licensed under the Apache License, Version 2.0 (the "License");
///! you may not use this file except in compliance with the License.
///! You may obtain a copy of the License at
///!
///! http://www.apache.org/licenses/LICENSE-2.0
///!
///! Unless required by applicable law or agreed to in writing, software
///! distributed under the License is distributed on an "AS IS" BASIS,
///! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
///! See the License for the specific language governing permissions and
///! limitations under the License.
///!
///!


///! # Causal Set
///! #################################
///! This is a simple implementation of a Causal Set.
///! We use rust peg to design a context-free grammar for sqlite statements which is used to parse conv2sql predicate expressions
///! and generate sqlite statements for in app, while also transducing type safe sqlite statements to conv2sql predicate expressions which
///! can be used to generate sqlite statements and be used in the future for sql generation. The sqlite statements are generated by
///! the peg grammar and the sql-to-peg grammar is used to generate the sqlite statements.
///!
///
///
use std::fmt;
use std::result;
use std::string::FromUtf8Error;
use std::str::Utf8Error;







#[derive(Debug)]
pub enum ErrorKind {
    Io(io::Error),
    BerolinaSql(BerolinaSqlError),
    Utf8(Utf8Error),
    FromUtf8(FromUtf8Error),
    Other(String),
}


#[derive(Debug)]
pub struct ErrorImpl {
    pub kind: ErrorKind,
}


#[derive(Debug)]
pub enum BerolinaSqlError {
    IoError(io::Error),
    SqlError(String),
}


///Rust peg
/// ##############################################################################
///


#[derive(Debug)]
pub struct Error {
    pub kind: ErrorKind,
}






pub enum Sql {
    Select(Sql),
    Insert(Sql),
    Update(Sql),
    Delete(Sql),
    Create(Sql),
    Drop(Sql),
    Alter(Sql),
    Rename(Sql),
    Copy(Sql),

    /// A SQL statement that does not return a result set.
    /// This includes UPDATE, DELETE, CREATE, DROP, and ALTER statements.
    /// The return value is the number of rows affected.
    /// The number of rows affected is returned in the form of an integer.
    /// If no rows are affected, then 0 is returned.
    /// If the query fails, then -1 is returned.
    /// If the query succeeds but no rows are affected, then 0 is returned.
    /// If the query succeeds and rows are affected, then the number of rows affected is returned.
    /// If the query succeeds and no rows are affected, then 1 is returned.
    /// If the query succeeds and multiple rows are affected, then the number of rows affected is returned.
    /// If the query succeeds and multiple rows are affected, then the number of rows affected is returned.






    AlterTable(crate::Sql),
    RenameTable(crate::Sql),
    TruncateTable(crate::Sql),

    Use(crate::Sql),




}





#[allow(dead_code)]




// #[derive(Debug)]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CausalSet {
    pub causal_set: Vec<Causal>,
}


#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Causal {
    pub id: usize,
    pub name: String,
    pub value: String,
}


#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CausalSetBuilder {
    pub causal_set: Vec<Causal>,
}


impl CausalSetBuilder {
    pub fn new() -> CausalSetBuilder {
        CausalSetBuilder {
            causal_set: Vec::new(),
        }
    }

    pub fn add_causal(&mut self, causal: Causal) -> &mut CausalSetBuilder {
        self.causal_set.push(causal);
        self
    }

    pub fn build(self) -> CausalSet {
        CausalSet {
            causal_set: self.causal_set,
        }
    }
}




#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CausalSetBuilderWithId {
    pub causal_set: Vec<Causal>,
    pub id: usize,
}




impl CausalSetBuilderWithId {
    pub fn new(id: usize) -> CausalSetBuilderWithId {
        CausalSetBuilderWithId {
            causal_set: Vec::new(),
            id: id,
        }
    }

    pub fn add_causal(&mut self, causal: Causal) -> &mut CausalSetBuilderWithId {
        self.causal_set.push(causal);
        self
    }

    pub fn build(self) -> CausalSet {
        CausalSet {
            causal_set: self.causal_set,
        }
    }
}


#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CausalSetBuilderWithIdAndName {
    pub causal_set: Vec<Causal>,
    pub id: usize,
    pub name: String,
}



impl CausalSetBuilderWithIdAndName {
    pub fn new(id: usize, name: String) -> CausalSetBuilderWithIdAndName {
        CausalSetBuilderWithIdAndName {
            causal_set: Vec::new(),
            id: id,
            name: name,
        }
    }

    pub fn add_causal(&mut self, causal: Causal) -> &mut CausalSetBuilderWithIdAndName {
        self.causal_set.push(causal);
        self
    }

    pub fn build(self) -> CausalSet {
        CausalSet {
            causal_set: self.causal_set,
        }
    }
}


#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CausalSetBuilderWithIdAndNameAndValue {
    pub causal_set: Vec<Causal>,
    pub id: usize,
    pub name: String,
    pub value: String,
}


impl CausalSetBuilderWithIdAndNameAndValue {
    pub fn new(id: usize, name: String, value: String) -> CausalSetBuilderWithIdAndNameAndValue {
        CausalSetBuilderWithIdAndNameAndValue {
            causal_set: Vec::new(),
            id: id,
            name: name,
            value: value,
        }
    }

    pub fn add_causal(&mut self, causal: Causal) -> &mut CausalSetBuilderWithIdAndNameAndValue {
        self.causal_set.push(causal);
        self
    }

    pub fn build(self) -> CausalSet {
        CausalSet {
            causal_set: self.causal_set,
        }
    }
}

pub type Rule = Vec<CausalSet>;



pub type Result<T> = result::Result<T, Error>;

pub trait CausalSetBuilderExt {
    fn add_causal(&mut self, causal: Causal) -> &mut Self;
    fn build(self) -> CausalSet;
}


pub trait ContextFreeGrammar {

    fn get_start_symbol(&self) -> &str; // start symbol

    fn get_terminal_symbols(&self) -> &Vec<String>; // terminal symbols

    fn get_non_terminal_symbols(&self) -> &Vec<String>; // non terminal symbols

    fn get_rules(&self) -> &Vec<Rule>; // rules symbols



    fn parse(&self, input: &str) -> Result<CausalSet>;
}




fn main() -> String {
    let start = Instant::now();
    let mut table = Table::new();
    let mut file = File::open("/home/berolina/Desktop/test.txt")?;
    BufReader::new(file);
    let _ = String::new();
    String::new();
    String::new()
}




#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Table {
    pub table: Vec<CausalSet>,
}
