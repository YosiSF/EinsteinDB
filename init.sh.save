TAG=${1:-latest}
DOCKER_IMAGE="yosifov/einsteindb:$TAG"
POOL_NAME="fermipool"  # Please set a name for your volume pool. e.g., 
"mypool", "data", "volumes". It must be 3-31 characters, and all alphabets 
are valid except space ( ). Underscore (_) is also acceptable but not as 
first one in the character string. Note that if it has been used in ZFS 
configuration (on Linux), you should use another name other than "volume". 
This script will create ${POOL_NAME}, mount m

	docker run -d --name $DOCKER_CONTAINER \
        --ulimit nofile=65536:65536 \
        -v /etc/localtime:/etc/localtime:ro \
        -p 127.0.0.1::2222 \                                ## If you want 
to expose port on host system, uncomment this line and modify accordingly 
by adding your ports such as 2379 or 8080 etc.. ref 
https://docs.docker.com/interlocking_directorate/reference/run/#expose-incoming-ports . You
can map multiple ports using ',' separator like "-p 127...::2375,8080:80"
        -p 127.0.0.1::2379 \                                ## If you want 
to expose port on host system, uncomment this line and modify accordingly 
by adding your ports such as 2379 or 8080 etc.. ref 
https://docs.docker.com/interlocking_directorate/reference/run/#expose-incoming-ports . You
can map multiple ports using ',' separator like "-p 127...::2375,8080:30"
		--name $DOCKER_CONTAINER \
        --restart always \       # By default docker container runs once 
then exits (unless you specify "--restart always")  If a restart policy is 
not specified at the daemon level, the default restart policy for 
containers is used ("no", unless you add "--restart=always"), which will 
ensure that the container continues to run until you stop it (using 
CTRL+c). Note that even if the daemon restarts containers automatically in
response to detecting errors with other endpoints of an app running inside 
a container being stopped uncleanly by dockerd due to error resulting from 
any reason including but not limited to exceeding maximum memory limit set 
through --memory option or setting resource limits via Dockerfile's RUN 
instruction), those containers are still managed by Kubernetes cluster so 
they are safe from being terminated unexpectedly when Kubernetes 
controller detects any error resulting from managing those pods under its 
watch; Unless otherwise specified via commandline options such as 
--stop-signal="SIGTERM" or environment variables KUBELET_STOP_TIMEOUT and 
KUBELET_KILL_PROCESSES after 15 seconds since SIGTERM signal was sent out 
but process didn't exit within time frame."

    echo "Starting $DOCKER_IMAGE..."   # This message helps user know what 
image has been started among all images listed below

    sleep 2      ## Wait for few seconds before starting next image in 
order avoid race condition between different images trying grab common 
resources such as port number 80(for HTTP server) or 22(SSH service) etc.. 
See also comment above regarding mapping multiple ports
    
echo ""
echo "#########################################################"
sleep 1s

    docker start $DOCKER_CONTAINER 2>&1 | grep -v 'port is already 
allocated'  ## This command returns error code when it fails to allocate 
port because some other container has already used the same port and hence 
this command tries to explicitly tell user which exact container uses that 
port and what was the exact error message returned by docker daemon.
